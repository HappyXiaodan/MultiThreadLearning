"# MultiThreadLearning" 
"# MultiThreadLearning" 
线程的风险  
1.安全危险  
  线程并发执行时，由于内存的可见性已经顺序执行被破坏可能会导致执行结果与预想期望不同的风险  
2.活跃度风险  
  即使保证了内存可见性以及顺序的有效执行，也会因为在多线程环境下发生线程竞争资源导致的线程的活跃度危险。  
eg：死锁，饥饿 ，活锁  
比如多个线程竞争A，B两个线程，A占有了B期望的资源，B锁了A的资源，如果咩有外力的作用，可能这两个资源会无休止的相互等待下去。  
Q：死锁发生的条件？  

3.性能风险  
  多线程的目的其中之一就是提高程序的系能，例如QPS，TPS，以及RT，如果线程不能处理好性能问题，那么多线程开发到不如单线程。  
并且计算机底层的线程切换会有一系列开销，所以我们可以在编译器层面（JVM）上多线程锁进行优化。例如：偏向锁锁会偏向当前持有锁的线程，参数-XX:+UsebaisedLocking默认启动的，在没有竞争的情况下，后的偏向锁的线程，在将来进入同步块石，不需要做同步，但是当其他线程请求相同的锁时，偏向模式结束，在竞争激烈的场合，偏向锁会增加系统的负担  
自旋锁：当竞争存在时，如果线程可以很快获得锁，那么可以不再OS层挂起线程，让线程做几个空操作，JDK1.6中-XX：+Usespinning开启，在1.7中，去掉了此参数，改为内置实现。  
若同步块很长，自旋失败，会降低系统的性能。若同步块很撑，自旋成功，节省线程挂起的切换时间，提高系统系能。  

可重入锁： 
  Reentrancy Lock，将锁的级别有每调用，改为每线程，通过没每个所关联一个请求技术和一个占有它的线程。  


volatile 变量也有限制，他可以保障内存可见性，但是并不能很好的支持自增操作的原子性。但枷锁可以保证原子性和内存可见性。  
发布和溢出  




concurrentHashMap
使用的是分离锁来提高并发的效率。（读写锁？）
在并发变成下，size和isEmpty这样的方法几乎没用处，因为目标是变化的，所以对这些操作的需求被弱化了  


Blocking queue 提供了课阻塞的put和take方法，若queue满了，put方法会被阻塞直到用空间可用，如果queue是空的，那么take方法将被阻塞，直到有元素可用。 
阻塞队列支持生产者消费者设计模式，用它可以解除生产者和消费者代码之间的依赖关系，降低了耦合度，推荐使用阻塞队列解决上述问题。
LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，
PriorityBlockingQueue是一个按优先级书序排序的队列可以用Comparatoy进行排序。
SynchronousQueue，这不是一个真正的队列，他不会为队列元素提供存储空间，适合消费者充足的场合。？？？

双端队列？？？  

latch闭锁，等待未完成的时间完成，再开始后续的作业。  
CountDownLatch包含一个计数器，初始化为一个整数，用来表现需要等待的事件数，countDown方法对计数器做减操作，表示一个时间已经发生。若计数器的值非零，则await会阻塞到计或者等待线程中断或超时。    


FutureTask 同样可以作为闭锁。接受callableTask，可以有返回值。  

信号量 semaphore，通过设定许可数permit，如果还有许可，则acquire会被阻塞，直到有可用的许可，release方法想信号量返回一个许可。  
它可以来实现资源池，比如数据库连接池。当它为空时，向他请求资源会失败。构建这种池比较简单，当池为空时，你需要阻塞它，当它不为空时，接触阻塞。，如果你以池的大小初始化一个semaphore，从池中获取资源之前，应该调用acquire方法获得一个许可，调用release方法将许可返回资源池。若资源池为空，这acquire方法会阻塞，直到池不再为空。  

关卡，barrier 类似于闭锁，它们都能够阻塞一组线程，直到某些事件发生。  
它与闭锁不同的是，关卡中所有线程必须同时到达关卡点，才能继续处理。而闭锁等待的是时间，关卡等待的是其他线程。  
cyclicbarrier  允许一个给定数量的成员多次集中在一个关卡点，这在并行迭代计算中非常有用，这个算法会将一个问题拆分成一系列互相独立的子问题。当线程到达关卡点时，调用await，await会被阻塞，直到所有线程都到达关卡点。如果所有的方法都被成功突破，这样所有线程都被释放，关卡会重置已被下次使用。如果await方法调用超市，或者线程都被释放，那么则认为关卡是失败的，所有对await方法未完成的调用都通过BrokenbarrierExcwption 终止。  
若成功的通过关卡，await方法为每一个线程返回一个唯一的到达索引号，可以用来选举产生一个领导。在不涉及IO或者访问共享数据是，Ncpu活Ncpu+1个线程产生最有吞吐量？？？（page101）  
Wxchanger是关卡的另一种形式。  


为计算结果简历高效，可伸缩的高速缓存。  
 几乎每一个服务器应用程序都使用某种形式的高速缓存，服用已有的计算结果可以多段等待时间，提高吞吐量，代价是占用更多的内存。 

Page109 






























