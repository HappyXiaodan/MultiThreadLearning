"# MultiThreadLearning" 
"# MultiThreadLearning" 
线程的风险  
1.安全危险  
  线程并发执行时，由于内存的可见性已经顺序执行被破坏可能会导致执行结果与预想期望不同的风险  
2.活跃度风险  
  即使保证了内存可见性以及顺序的有效执行，也会因为在多线程环境下发生线程竞争资源导致的线程的活跃度危险。  
eg：死锁，饥饿 ，活锁  
比如多个线程竞争A，B两个线程，A占有了B期望的资源，B锁了A的资源，如果咩有外力的作用，可能这两个资源会无休止的相互等待下去。  
Q：死锁发生的条件？  

3.性能风险  
  多线程的目的其中之一就是提高程序的系能，例如QPS，TPS，以及RT，如果线程不能处理好性能问题，那么多线程开发到不如单线程。  
并且计算机底层的线程切换会有一系列开销，所以我们可以在编译器层面（JVM）上多线程锁进行优化。例如：偏向锁锁会偏向当前持有锁的线程，参数-XX:+UsebaisedLocking默认启动的，在没有竞争的情况下，后的偏向锁的线程，在将来进入同步块石，不需要做同步，但是当其他线程请求相同的锁时，偏向模式结束，在竞争激烈的场合，偏向锁会增加系统的负担  
自旋锁：当竞争存在时，如果线程可以很快获得锁，那么可以不再OS层挂起线程，让线程做几个空操作，JDK1.6中-XX：+Usespinning开启，在1.7中，去掉了此参数，改为内置实现。  
若同步块很长，自旋失败，会降低系统的性能。若同步块很撑，自旋成功，节省线程挂起的切换时间，提高系统系能。  

可重入锁： 
  Reentrancy Lock，将锁的级别有每调用，改为每线程，通过没每个所关联一个请求技术和一个占有它的线程。  


























